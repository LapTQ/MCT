@startuml


@enduml

' Công việc cần thực hiện:
'   + luôn phải có bản ghi trong Productivity cho mỗi cặp (user, ngày, ca làm) dù người đó có arrive không
'   + thời điểm lưu db kết quả track, sta là sau ca làm (hoặc cuối ngày) => giảm latency
'   + nếu người đó tới muộn thì ngay khi người đó tới phải gửi thông báo
'   + thời điểm lưu db về arrival và staying time là sau ca làm (hoặc cuối ngày) => giảm latency
' Cách 1: Monitor phải <<create>>User ngay khi bản thân nó khởi tạo (để tính cả thời gian đến muộn nữa)


' Cách 2: Chỉ khi nào nhận được signal_signin thì mới khởi tạo.
'   Yêu cầu:
'       - User phải định nghĩa các phương thức: check_late và gọi tới hàm này ngay trong phần __init__ của nó.
'           for t in T:
'               if signin_id is not None:
'                   u = User(id)        # chạy hàm check_late, trong hàm này phải gửi thông báo đến manager
'                   users.append(u)
'       - Monitor phải <<destruct>> instance User này ngay khi ca làm của nó hết:
'           for t in T:
'               ...
'               for u in users:
'                   end_time = find_endtime(u)     # tìm thời điểm kết thúc của ca làm hiện tại (HOẶC gần nhất vì có thể t đã muộn hơn vài ms so với end_time)
'                   if t > end_time:
'                       <<destrut>>(u)
'       _ Hoặc là phải tạo bản ghi trong bảng Productivity cho từng user (dù có arrive hay chưa) ngay khi ca làm mới CỦA NGƯỜI ĐÓ bắt đầu => vẫn cần quét qua TẤT CẢ các user ngay khi ca làm bắt đầu dù cho có signal_id chưa
'           for t in T:
'               ...
'               for u in User.query.all():
'                   if t > find_startime(u)     # hmmm với mọi t mà làm thế này thì rất tốn kém
'                       p = Productivity(u, date, dayshift)
'         HOẶC là tạo bản ghi Productivity trong __init__ của User. Với những user không trốn làm, thì sau mỗi ca tan phải lọc lấy những người này và tạo bản ghi Productivity
'           => vẫn rất tốn kém
'       => cách 2 này KHÔNG HỢP LÝ
